# ソート

## 選択ソート

リスト内の最小値を逐一探し出し、先頭と交換。
交換することで、リスト内で最も小さい値が先頭へ配置されたので、
先頭を除外し、再度最小値を探索。2番目と最小値を交換。

これをリストの末尾がソート済みである状態となるまで繰り返し。

```Python
# 疑似コード

def 選択ソート(対象リスト):
    
    for すべての要素が並べ替え済みとなるまで:
        
        for 並べ替え済み ~ リストの末尾まで:
            最小値を更新
            
        並べ替え前の要素の先頭と最小値の要素を入れ替え
    
    ソート済みリストを返却
```

---

## バブルソート

選択ソートと同様、すべての要素が並べ替え済みとなるまで処理を継続。
選択ソートとの違いは、最小/最大値を探してから並べ替えるのではなく、
先頭/末尾へ到達するまで大小比較/並べ替えを繰り返すところにある。

並べ替え・探索を繰り返す様が泡のように連続していることから、「バブルソート」
という名前がつけられた。

```Python
# 疑似コード

def バブルソート(対象リスト):
    for すべての要素が並べ替え済みとなるまで:
        
        for 末尾 ~ 並べ替え済みまで:
            左 = 現在要素の1つ前の参照
            右 = 現在要素の参照
        
            if 左 > 右:
                左右を並び替え
    ソート済みリストを返却
```


## 挿入ソート

各要素を、並べ替え済みとしてあるべき位置へ挿入。

バブルソートが並べ替え前のもので比較・入れ替えしていたのに対し、
挿入ソートは、並べ替え済みが対象となる。

```Python
# 疑似コード

def 挿入ソート(対象リスト):
    for すべての要素が並べ替え済みとなるまで:

        for 先頭 ~ 並べ替え済みの末尾まで:
            if 左(1つ前の参照) > 右(現在の参照):
                左右入れ替え

    ソート済みリストを返却
```

## 三種のアルゴリズムの考え方の違い

これまでに見てきた三つのソートアルゴリズムは、いずれも二重ループでリストを
並び替えていく、という点で共通している。

ざっとコードを眺めただけでは、頭の中で区別するのに苦戦したので、
それぞれがどう異なるのか、改めて言語化しておきたい。
具体的には、動作イメージ・最良/最悪の計算量・どういうときに使うと良さそうかを明らかにしたい。

できれば、平均計算量まで導出したかったが、まだまだ不慣れなこともあり、厳しそう...。
まずは可能な範囲で言語化しておき、力がついてきたらより深掘りしていくか。


### 選択ソート

リストがどのような状態であっても、探索回数が固定される。
実装が非常にシンプルになるが、動作面ではデメリットが多そう。
最悪計算量は、N個の要素からなるリストに対して、`N-1 + N-2 + ... + 1 = O(N^2)`となる。
これは、`N-1`が`(N / 2)個`存在することによる。

まず使うことは無さそうだが、選択ソートへの橋渡しによいか。

### バブルソート

計算量・探索回数共に選択ソートと同じ。
違いは、探索と並び替えが同時並行に進む点ぐらいか。

直感的に掴みやすいとも言えないし、選択ソートと比較して優位性は無さそう。

### 挿入ソート

最悪計算量は選択/バブルソートと同じくO(N^2)。
ただし、並べ替えが発生するのが、`未ソート済みの要素 < ソート済み要素の末尾`なので、
ある程度昇順にソートされていれば、多少速度は改善される。
具体的には、昇順にソート済みであれば、並べ替えが発生しないことから、O(N)で完了する。

※ 比較自体は発生しているので、これをO(N)と言い切ってよいかは疑問が残る。

---

## クイックソート

二分探索のように、軸を決めてリストを二分しながらソートしていく手法。
対象リストを次々に二分することから効率が良く、一般的にもよく使われる。

### 考え方

クイックソートはアルゴリズムが複雑なので、段階を踏んで考える。
最初に、主な流れを示す。

* 要素数が1の場合は、引数で受け取ったリストをそのまま返却
* 要素数が2以上の場合は、軸(ピボット)をリストから選択 ※ 今回はシンプルに考えるため、先頭を採用
* リスト内の要素を、ピボットとの大小関係から左・右のサブリストへ振り分け
* このとき、「左の要素 < ピボット < 右の要素」の大小関係が成り立つ
* 左のサブリストへ同様の処理を適用した結果・ピボット・右のサブリストへ同様の処理を適用した結果を返却すると、ソート済みリストが得られる

#### 要素数=1のとき

要素数が1つのときは、ソートの必要がないので、ソート対象リストをそのまま返却。

#### 要素数=2のとき

要素数が2つ以上になると、クイックソートのアルゴリズムが適用されるようになる。
最初に、ピボットを選択。
続いて、ピボットを除くリスト内の要素(要素数=1)からサブリストを作成。

このとき、「リスト内の要素 < ピボット」であれば、左のみ・「リスト内の要素 > ピボット」であれば右のみが作成される。
※ シンプルに考えるため、ピボットと同一の値は考慮しない。

左右いずれにサブリストが作成されても、再帰的に処理を呼び出すと、サブリストの要素数が1であることから、
サブリストがそのまま返却される。
得られたサブリストとピボットを、左→ピボット→右の順に結合すると、ソート済みのリストが得られる。

#### 要素数=3のとき

要素数が3のときと要素数が2の場合との違いは、ピボットからサブリストをつくるときに表れる。
具体的には、サブリストの場合分けのパターンが増え、下のようになる。

* 左のみ(左の要素数=2)
* 右のみ(右の要素数=2)
* 左右1つずつ

順に考えてみると、左右一方のみの場合は、サブリストに対して、要素数=2のクイックソートのアルゴリズムが適用される。
これは、上記にて検証済みであるため、ソート済みのリストが得られる。
つまり、左→ピボット→右の順に結合すれば、要素数が3つであっても、同様にソート済みのリストが手に入るのである。
一方、左右ばらばら(要素数が1つずつ)の場合は、よりシンプルに考えられる。
要素数が1の場合は、再帰的にソート処理を呼び出しても、サブリストがそのまま返却されるので、
サブリストとピボットを結合するだけで、ソートが完了する。

#### 要素数=nのとき

以降はこれまでに見てきたロジックを流用することで解決できるので、一般化して考えてみる。
例えば、要素数が4つになったとしても、ピボットを除けば、サブリストは3つ以下となり、上の考えが適用できる。
5つ、6つと増えた場合でも、ピボットによる分割を繰り返すだけで、ソート済みのリストが得られる。

つまり、要素数が増えたとしても、要素数=3までの考え方をコードで表現するだけで、任意の長さのリストのソートを
解決できる。

### 擬似コード

具体的にどのようなコードを書くか、擬似コードで整理してみる。

```Python
from typing import List


def sort_by_pivot(source_list: List[int]) -> List[int]:
    
    # 要素数 <= 1 これ以上ソートする必要がないので、対象リストをそのまま返却
    if len(source_list) <= 1:
        return source_list

    # 軸を決定
    pivot = source_list[0]
    # サブリスト
    left: List[int] = []
    right: List[int] = []
    
    for item in source_list:
        # 大小関係から左右へ振り分け
        if item < pivot:
            left.append(item)
            continue
            
        if item > pivot:
            right.append(item)
            continue

    # ソート済みの左のサブリスト→ピボット→ソート済みの右のサブリストの順に結合することで、ソート済みリストが得られる
    return sort_by_pivot(left) + [pivot] + sort_by_pivot(right)
```


## マージソート

リストをサブリストへ分割し、段階的にマージすることでソートを実現。
サブリストのマージ→マージされたサブリスト同士のマージ→...と繰り返していくことで、大きなサイズのリストにも対応できる。

マージソートもクイックソートと同様、問題を分割することが重要である。
よって、ここでもn=1から始め、段階的に処理を追っていく。

### 考え方

全体像を見失わないよう、最初にマージソートの主な流れを書く。

* リストの要素数が1つの場合は、ソート済みであるとして、リストをそのまま返却
* 中心を軸にリストを二分割
* 二分割されたサブリスト(それぞれ左, 右と呼ぶ)を左右の要素数が1以下となるまで再帰的に分割
* 左右のサブリストを「マージ」した結果を呼び出し元へ返却
* 順々にマージしながら最初の呼び出し元へ返却していく
* マージするときに並べ替えていくことで、結果的にソート済みのリストが得られる

#### n=1

要素数が1つの場合は、既にソート済みであるため、リストをそのまま返却。

#### n=2

1回の分割が発生。その結果、左右それぞれ要素数が1のサブリストが作成される。
左右をマージするとき、小さい要素を先にソート済みリストへ格納していくことで、並べ替えを実現。

分割は1回でn=1のときの分岐により打ち切られるので、1回のマージで処理が完結。
戻り値からソート済みのリストが得られる。

#### n=3

2回の分割が発生。
具体的には、1回目の分割でn=1, n=2のサブリストが作成される。n=2のサブリストは、要素数が1でないことから、もう一度分割される。

順に処理の流れを追ってみる。ここで、左がn=1, 右がn=2と仮定。
左は既にソート済みなので、分割終了。
右は要素数が1より大きいので、再度分割。n=1のサブリストが左右に1つずつ作成される。
サブリストを並べ替えてマージし、ソート済みのn=2のリストが返却される。

左(n=1のソート済みリスト)と、右(n=2のソート済みリスト)をマージ。
左右から小さい順にマージ済みリストへ格納していくことで、ソート済みリストが得られる。

#### n=k

k-1回の分割が発生。
分割したものをマージしていくと、サブリストの要素数は、1→2→4→8→...と増えていく。
要素数が増えても、これまで追ってきた流れと同様、呼び出し元へマージしたリストを返却していくことを
繰り返せば、元の要素数が復元できたとき、ソート済みのリストが得られる。

### 擬似コード

以上の流れを擬似コードで表現してみる。

```Python
import math
from typing import List

# 2つのサブリストをマージ
def merge(left: List[int], right: List[int]) -> List[int]:
    
    # マージ結果を格納
    merged = []
    
    while True:
        # すべてマージ完了となったら呼び出し元へマージ結果を返却
        if len(left) == 0 and len(right) == 0:
            return merged
        
        # 左が既に空の場合、右の要素をマージ結果へ追加
        # 大小比較の結果左右のリストは既にソート済みであるため、そのまま格納してよい
        if len(left) == 0:
            merged.append(right.pop(0))
            continue
        if len(right) == 0:
            merged.append(left.pop(0))
            continue
            
        # マージ元は、サブリスト内でソート済みなので、先頭から大小比較を繰り返し、
        # マージ結果へ詰め込むことで、ソート済みリストが得られる
        if left[0] < right[0]:
            merged.append(left.pop(0))
            continue
        if left[0] > right[0]:
            merged.append(right.pop(0))
            continue
            

def sort_by_merge(source_list: List[int]) -> List[int]:
    
    # 要素数が1の場合はソート済みなので、そのまま返却
    if len(source_list) == 0:
        return source_list
    
    # リストを二分するための基準
    center = math.floor(len(source_list) / 2)
    left = source_list[:center]
    right = source_list[center:]
    
    # 要素数が1つになるまで分割を繰り返す
    left = sort_by_merge(left)
    right = sort_by_merge(right)
    
    # マージ結果を呼び出し元へ返却することで、ソート済みリストが得られる
    return merge(left, right)
```