# ソート

## 選択ソート

リスト内の最小値を逐一探し出し、先頭と交換。
交換することで、リスト内で最も小さい値が先頭へ配置されたので、
先頭を除外し、再度最小値を探索。2番目と最小値を交換。

これをリストの末尾がソート済みである状態となるまで繰り返し。

```Python
# 疑似コード

def 選択ソート(対象リスト):
    
    for すべての要素が並べ替え済みとなるまで:
        
        for 並べ替え済み ~ リストの末尾まで:
            最小値を更新
            
        並べ替え前の要素の先頭と最小値の要素を入れ替え
    
    ソート済みリストを返却
```

---

## バブルソート

選択ソートと同様、すべての要素が並べ替え済みとなるまで処理を継続。
選択ソートとの違いは、最小/最大値を探してから並べ替えるのではなく、
先頭/末尾へ到達するまで大小比較/並べ替えを繰り返すところにある。

並べ替え・探索を繰り返す様が泡のように連続していることから、「バブルソート」
という名前がつけられた。

```Python
# 疑似コード

def バブルソート(対象リスト):
    for すべての要素が並べ替え済みとなるまで:
        
        for 末尾 ~ 並べ替え済みまで:
            左 = 現在要素の1つ前の参照
            右 = 現在要素の参照
        
            if 左 > 右:
                左右を並び替え
    ソート済みリストを返却
```


## 挿入ソート

各要素を、並べ替え済みとしてあるべき位置へ挿入。

バブルソートが並べ替え前のもので比較・入れ替えしていたのに対し、
挿入ソートは、並べ替え済みが対象となる。

```Python
# 疑似コード

def 挿入ソート(対象リスト):
    for すべての要素が並べ替え済みとなるまで:

        for 先頭 ~ 並べ替え済みの末尾まで:
            if 左(1つ前の参照) > 右(現在の参照):
                左右入れ替え

    ソート済みリストを返却
```

## 三種のアルゴリズムの考え方の違い

これまでに見てきた三つのソートアルゴリズムは、いずれも二重ループでリストを
並び替えていく、という点で共通している。

ざっとコードを眺めただけでは、頭の中で区別するのに苦戦したので、
それぞれがどう異なるのか、改めて言語化しておきたい。
具体的には、動作イメージ・最良/最悪の計算量・どういうときに使うと良さそうかを明らかにしたい。

できれば、平均計算量まで導出したかったが、まだまだ不慣れなこともあり、厳しそう...。
まずは可能な範囲で言語化しておき、力がついてきたらより深掘りしていくか。


### 選択ソート

リストがどのような状態であっても、探索回数が固定される。
実装が非常にシンプルになるが、動作面ではデメリットが多そう。
最悪計算量は、N個の要素からなるリストに対して、`N-1 + N-2 + ... + 1 = O(N^2)`となる。
これは、`N-1`が`(N / 2)個`存在することによる。

まず使うことは無さそうだが、選択ソートへの橋渡しによいか。

### バブルソート

計算量・探索回数共に選択ソートと同じ。
違いは、探索と並び替えが同時並行に進む点ぐらいか。

直感的に掴みやすいとも言えないし、選択ソートと比較して優位性は無さそう。

### 挿入ソート

最悪計算量は選択/バブルソートと同じくO(N^2)。
ただし、並べ替えが発生するのが、`未ソート済みの要素 < ソート済み要素の末尾`なので、
ある程度昇順にソートされていれば、多少速度は改善される。
具体的には、昇順にソート済みであれば、並べ替えが発生しないことから、O(N)で完了する。

※ 比較自体は発生しているので、これをO(N)と言い切ってよいかは疑問が残る。

---

## クイックソート

二分探索のように、軸を決めてリストを二分しながらソートしていく手法。
対象リストを次々に二分することから効率が良く、一般的にもよく使われる。

### 考え方

クイックソートはアルゴリズムが複雑なので、段階を踏んで考える。
最初に、主な流れを示す。

* 要素数が1の場合は、引数で受け取ったリストをそのまま返却
* 要素数が2以上の場合は、軸(ピボット)をリストから選択 ※ 今回はシンプルに考えるため、先頭を採用
* リスト内の要素を、ピボットとの大小関係から左・右のサブリストへ振り分け
* このとき、「左の要素 < ピボット < 右の要素」の大小関係が成り立つ
* 左のサブリストへ同様の処理を適用した結果・ピボット・右のサブリストへ同様の処理を適用した結果を返却すると、ソート済みリストが得られる

#### 要素数=1のとき

要素数が1つのときは、ソートの必要がないので、ソート対象リストをそのまま返却。

#### 要素数=2のとき

要素数が2つ以上になると、クイックソートのアルゴリズムが適用されるようになる。
最初に、ピボットを選択。
続いて、ピボットを除くリスト内の要素(要素数=1)からサブリストを作成。

このとき、「リスト内の要素 < ピボット」であれば、左のみ・「リスト内の要素 > ピボット」であれば右のみが作成される。
※ シンプルに考えるため、ピボットと同一の値は考慮しない。

左右いずれにサブリストが作成されても、再帰的に処理を呼び出すと、サブリストの要素数が1であることから、
サブリストがそのまま返却される。
得られたサブリストとピボットを、左→ピボット→右の順に結合すると、ソート済みのリストが得られる。

#### 要素数=3のとき

要素数が3のときと要素数が2の場合との違いは、ピボットからサブリストをつくるときに表れる。
具体的には、サブリストの場合分けのパターンが増え、下のようになる。

* 左のみ(左の要素数=2)
* 右のみ(右の要素数=2)
* 左右1つずつ

順に考えてみると、左右一方のみの場合は、サブリストに対して、要素数=2のクイックソートのアルゴリズムが適用される。
これは、上記にて検証済みであるため、ソート済みのリストが得られる。
つまり、左→ピボット→右の順に結合すれば、要素数が3つであっても、同様にソート済みのリストが手に入るのである。
一方、左右ばらばら(要素数が1つずつ)の場合は、よりシンプルに考えられる。
要素数が1の場合は、再帰的にソート処理を呼び出しても、サブリストがそのまま返却されるので、
サブリストとピボットを結合するだけで、ソートが完了する。

#### 要素数=nのとき

以降はこれまでに見てきたロジックを流用することで解決できるので、一般化して考えてみる。
例えば、要素数が4つになったとしても、ピボットを除けば、サブリストは3つ以下となり、上の考えが適用できる。
5つ、6つと増えた場合でも、ピボットによる分割を繰り返すだけで、ソート済みのリストが得られる。

つまり、要素数が増えたとしても、要素数=3までの考え方をコードで表現するだけで、任意の長さのリストのソートを
解決できる。

### 擬似コード

具体的にどのようなコードを書くか、擬似コードで整理してみる。

```Python
from typing import List


def sort_by_pivot(source_list: List[int]) -> List[int]:
    
    # 要素数 <= 1 これ以上ソートする必要がないので、対象リストをそのまま返却
    if len(source_list) <= 1:
        return source_list

    # 軸を決定
    pivot = source_list[0]
    # サブリスト
    left: List[int] = []
    right: List[int] = []
    
    for item in source_list:
        # 大小関係から左右へ振り分け
        if item < pivot:
            left.append(item)
            continue
            
        if item > pivot:
            right.append(item)
            continue

    # ソート済みの左のサブリスト→ピボット→ソート済みの右のサブリストの順に結合することで、ソート済みリストが得られる
    return sort_by_pivot(left) + [pivot] + sort_by_pivot(right)
```